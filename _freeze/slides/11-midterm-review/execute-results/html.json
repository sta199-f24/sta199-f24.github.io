{
  "hash": "721b60636fae81599ef9afc9a11ee1b3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Midterm review\"\nsubtitle: \"Lecture 11\"\ndate: \"2024-10-03\"\nformat: \n  live-revealjs: \n    output-file: 11-midterm-review-slides.html\n    webr:\n      cell-options:\n        autorun: true\n      packages:\n        - tidyverse\n        - openintro\n        - ggthemes\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n<!-- begin: webr fodder -->\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| echo: false\n#| output: false\noptions(width = 60)\n```\n:::\n\n\n\n\n\n\n<!-- end: webr fodder -->\n\n<!-- begin: ae definition -->\n\n\n\n\n\n\n\n\n\n<!-- end: ae definition -->\n\n# Warm-up\n\n## While you wait...\n\n-   Go to your ae project in RStudio\n\n-   Make sure you have each piece of information we need extracted from The Chronicle opinion page – up to `create a data frame` in `chronicle-scrape.R`.\n\n## Announcements\n\nMidterm things:\n\n-   Exam room: Bio Sci 111 or Gross Hall 107\n\n-   Cheat sheet: 8.5x11, both sides, hand written or typed, any content you want, must be prepared by you\n\n-   Also bring a pencil and eraser (you're allowed to use a pen, but you might not want to)\n\n-   Reminder: Academic dishonesty / Duke Community Standard\n\n# From last time: `ae-10`\n\n## Opinion articles in The Chronicle\n\n::::: columns\n::: {.column width=\"50%\"}\n-   Scrape data and organize it in a tidy format in R\n-   Perform light text parsing to clean data\n-   Summarize and visualize the data\n:::\n\n::: {.column width=\"50%\"}\n![](images/10/chronicle-data.png){fig-align=\"center\"}\n:::\n:::::\n\n## `ae-10-chronicle-scrape` {.smaller}\n\n::: appex\n-   Go to your ae project in RStudio.\n\n-   Open `chronicle-scrape.R` and `ae-10-chronicle-scrape.qmd`.\n:::\n\n## Recap\n\n-   Use the SelectorGadget identify tags for elements you want to grab\n-   Use rvest to first read the whole page (into R) and then parse the object you've read in to the elements you're interested in\n-   Put the components together in a data frame (a tibble) and analyze it like you analyze any other data\n\n## A new R workflow {.smaller}\n\n-   When working in a Quarto document, your analysis is re-run each time you knit\n\n-   If web scraping in a Quarto document, you'd be re-scraping the data each time you knit, which is undesirable (and not *nice*)!\n\n-   An alternative workflow:\n\n    -   Use an R script to save your code\n    -   Saving interim data scraped using the code in the script as CSV or RDS files\n    -   Use the saved data in your analysis in your Quarto document\n\n# From a previous time: `ae-09-age-gaps-sales-import` - Part 2\n\n## `ae-09-age-gaps-sales-import` {.smaller}\n\n::: appex\n-   Go to your ae project in RStudio.\n\n-   Open `ae-09-age-gaps-sales-import.qmd` - Part 2.\n:::\n\n# Review: Quarto workflow\n\n## Your document environment vs. your global environment\n\n-   Objects you define in your Quarto document are available in your Quarto document, and if you ran that code cell individually, they will also be available in your global environment\n\n-   Objects you define in your global environment are not, by default, available in your Quarto document\n\n## Recipe for success for reproducible documents\n\n-   Render -- after each \"win\" or at each stopping point\n\n-   Commit -- all files, with a commit message that describes the substance of what you did\n\n-   Push -- to make sure files are updated on GitHub as well\n\n# Questions... or...\n\n# Time permitting: Type coercion\n\n## Explicit vs. implicit type coercion\n\n-   Explicit type coercion: You ask R to change the type of a variable\n\n-   Implicit type coercion: R changes / makes assumptions for you about the type of a variable without you asking for it\n\n    -   This happens because in a vector, you can't have multiple types of values\n\n## Vectors {.smaller}\n\n::: incremental\n-   A vector is a collection of values\n\n    -   Atomic vectors can only contain values of the same type\n\n    -   Lists can contain values of different types\n\n-   Why do we care?\n    Because each column of a data frame is a vector.\n:::\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3|4\"}\ndf <- tibble(\n  x = c(1, 2, 3),          # numeric (double)\n  y = c(\"a\", \"b\", \"c\"),    # character\n  z = c(TRUE, FALSE, TRUE) # logical\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n      x y     z    \n  <dbl> <chr> <lgl>\n1     1 a     TRUE \n2     2 b     FALSE\n3     3 c     TRUE \n```\n\n\n:::\n:::\n\n\n\n\n## Explicit coercion\n\n✅ From numeric to character\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2\"}\ndf |>\n  mutate(x_new = as.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      x y     z     x_new\n  <dbl> <chr> <lgl> <chr>\n1     1 a     TRUE  1    \n2     2 b     FALSE 2    \n3     3 c     TRUE  3    \n```\n\n\n:::\n:::\n\n\n\n\n## Explicit coercion\n\n❌ From character to numeric\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2\"}\ndf |>\n  mutate(y_new = as.numeric(y))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `y_new = as.numeric(y)`.\nCaused by warning:\n! NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      x y     z     y_new\n  <dbl> <chr> <lgl> <dbl>\n1     1 a     TRUE     NA\n2     2 b     FALSE    NA\n3     3 c     TRUE     NA\n```\n\n\n:::\n:::\n\n\n\n\n## Implicit coercion\n\n::: question\nWhich of the column types were implicitly coerced?\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\ndf <- tibble(\n  w = c(1, 2, 3),\n  x = c(\"a\", \"b\", 4),\n  y = c(\"c\", \"d\", NA),\n  z = c(5, 6, NA),\n)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      w x     y         z\n  <dbl> <chr> <chr> <dbl>\n1     1 a     c         5\n2     2 b     d         6\n3     3 4     <NA>     NA\n```\n\n\n:::\n:::\n\n\n\n\n## Collecting data {.smaller}\n\n::: question\nSuppose you conduct a survey and ask students their student ID number and number of credits they're taking this semester.\nWhat is the type of each variable?\n:::\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey_raw <- tibble(\n  student_id = c(273674, 298765, 287129, \"I don't remember\"),\n  n_credits = c(4, 4.5, \"I'm not sure yet\", \"2 - underloading\")\n)\nsurvey_raw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  student_id       n_credits       \n  <chr>            <chr>           \n1 273674           4               \n2 298765           4.5             \n3 287129           I'm not sure yet\n4 I don't remember 2 - underloading\n```\n\n\n:::\n:::\n\n\n\n\n## Cleaning data {.smaller}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey <- survey_raw |>\n  mutate(\n    student_id = if_else(student_id == \"I don't remember\", NA, student_id),\n    n_credits = case_when(\n      n_credits == \"I'm not sure yet\" ~ NA,\n      n_credits == \"2 - underloading\" ~ \"2\",\n      .default = n_credits\n    ),\n    n_credits = as.numeric(n_credits)\n  )\nsurvey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  student_id n_credits\n  <chr>          <dbl>\n1 273674           4  \n2 298765           4.5\n3 287129          NA  \n4 <NA>             2  \n```\n\n\n:::\n:::\n\n\n\n\n## Cleaning data -- alternative {.smaller}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey <- survey_raw |>\n  mutate(\n    student_id = parse_number(student_id),\n    n_credits = parse_number(n_credits)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `student_id = parse_number(student_id)`.\nCaused by warning:\n! 1 parsing failure.\nrow col expected           actual\n  4  -- a number I don't remember\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nsurvey\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  student_id n_credits\n       <dbl>     <dbl>\n1     273674       4  \n2     298765       4.5\n3     287129      NA  \n4         NA       2  \n```\n\n\n:::\n:::\n\n\n\n\n## Recap: Type coercion\n\n::: incremental\n-   If variables in a data frame have multiple types of values, R will coerce them into a single type, which may or may not be what you want.\n\n-   If what R does by default is not what you want, you can use explicit coercion functions like `as.numeric()`, `as.character()`, etc. to turn them into the types you want them to be, which will generally also involve cleaning up the features of the data that caused the unwanted implicit coercion in the first place.\n:::\n\n# Time permitting: Aesthetic mappings\n\n## `openintro::loan50`\n\n\n\n\n::: {.cell}\n```{webr}\n#| message: false\nlibrary(tidyverse)\nlibrary(openintro)\nlibrary(ggthemes)\n```\n:::\n\n::: {.cell}\n```{webr}\nloan50 |>\n  select(annual_income, interest_rate, homeownership)\n```\n:::\n\n\n\n\n## Aesthetic mappings\n\n::: question\nWhat will the following code result in?\n:::\n\n\n\n\n::: {.cell autorun='false'}\n```{webr}\n#| label: mapping\n#| autorun: false\nggplot(\n  loan50,\n  aes(\n    x = annual_income, y = interest_rate,\n    color = homeownership, shape = homeownership\n  )\n) +\n  geom_point() +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n## Global mappings\n\n::: question\nWhat will the following code result in?\n:::\n\n\n\n\n::: {.cell autorun='false'}\n```{webr}\n#| label: global-mapping\n#| autorun: false\nggplot(\n  loan50,\n  aes(\n  x = annual_income, y = interest_rate, \n  color = homeownership, shape = homeownership\n  )\n) +\n  geom_point() +\n  geom_smooth(se = FALSE) +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n## Local mappings\n\n::: question\nWhat will the following code result in?\n:::\n\n\n\n\n::: {.cell autorun='false'}\n```{webr}\n#| label: mapping-local\n#| autorun: false\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate)\n) +\n  geom_point(aes(color = homeownership)) +\n  geom_smooth(se = FALSE) +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n## Mapping vs. setting\n\n::: question\nWhat will the following code result in?\n:::\n\n\n\n\n::: {.cell autorun='false'}\n```{webr}\n#| label: mapping-setting\n#| autorun: false\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate)\n) +\n  geom_point(aes(color = homeownership)) +\n  geom_smooth(color = \"red\", se = FALSE) +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n## Recap: Aesthetic mappings\n\n::: incremental\n-   Aesthetic mapping defined at the *global* level will be used by all `geom`s for which the aesthetic is defined.\n\n-   Aesthetic mapping defined at the *local* level will be used only by the `geom`s they're defined for.\n:::\n\n## Aside: Legends\n\n\n\n\n::: {.cell}\n```{webr}\n#| fig-width: 8\n#| fig-asp: 0.5\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind()\n```\n:::\n\n\n\n\n## Aside: Legends {.smaller}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|7\"}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind() +\n  labs(color = \"Home ownership\")\n```\n\n::: {.cell-output-display}\n![](11-midterm-review_files/figure-revealjs/unnamed-chunk-20-1.png){width=768}\n:::\n:::\n\n\n\n\n## Aside: Legends {.smaller}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|8-9\"}\nggplot(\n  loan50,\n  aes(x = annual_income, y = interest_rate, color = homeownership, shape = homeownership)\n) +\n  geom_point() +\n  scale_color_colorblind() +\n  labs(\n    color = \"Home ownership\",\n    shape = \"Home ownership\"\n  )\n```\n\n::: {.cell-output-display}\n![](11-midterm-review_files/figure-revealjs/unnamed-chunk-21-1.png){width=768}\n:::\n:::\n\n\n\n\n# Time permitting: Factors\n\n## Factors\n\n-   Factors are used for categorical variables -- variables that have a fixed and known set of possible values.\n\n-   They are also useful when you want to display character vectors in a non-alphabetical order.\n\n::: aside\nR4DS: <https://r4ds.hadley.nz/factors>.\n:::\n\n## Bar plot\n\n\n\n\n::: {.cell}\n```{webr}\nggplot(loan50, aes(x = homeownership)) +\n  geom_bar()\n```\n:::\n\n\n\n\n## Bar plot - reordered\n\n\n\n\n::: {.cell}\n```{webr}\nloan50 |>\n  mutate(homeownership = fct_relevel(homeownership, \"mortgage\", \"rent\", \"own\")) |>\n  ggplot(aes(x = homeownership)) +\n  geom_bar()\n```\n:::\n\n\n\n\n## Frequency table\n\n\n\n\n::: {.cell}\n```{webr}\nloan50 |>\n  count(homeownership)\n```\n:::\n\n\n\n\n## Bar plot - reordered\n\n\n\n\n::: {.cell}\n```{webr}\nloan50 |>\n  mutate(homeownership = fct_relevel(homeownership, \"own\", \"rent\", \"mortgage\")) |>\n  count(homeownership)\n```\n:::\n\n\n\n\n## Under the hood\n\n\n\n\n::: {.cell}\n```{webr}\nclass(loan50$homeownership)\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n```{webr}\ntypeof(loan50$homeownership)\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n```{webr}\nlevels(loan50$homeownership)\n```\n:::\n\n\n\n\n## Recap: Factors\n\n::: incremental\n-   The **forcats** package has a bunch of functions (that start with `fct_*()`) for dealing with factors and their levels: <https://forcats.tidyverse.org/reference/index.html>\n\n-   Factors and the order of their levels are relevant for displays (tables, plots) and they'll be relevant for modeling (later in the course)\n\n-   `factor` is a data **class**\n:::\n\n## Aside: `==`\n\n\n\n\n::: {.cell}\n```{webr}\nloan50 |>\n  mutate(homeownership_new = if_else(homeownership == \"rent\", \"don't own\", homeownership)) |>\n  distinct(homeownership, homeownership_new)\n```\n:::\n\n\n\n\n## Aside: `|`\n\n\n\n\n::: {.cell}\n```{webr}\nloan50 |>\n  mutate(homeownership_new = if_else(homeownership == \"rent\" | homeownership == \"mortgage\", \"don't own\", homeownership)) |>\n  distinct(homeownership, homeownership_new)\n```\n:::\n\n\n\n\n## Aside: `|`\n\n\n\n\n::: {.cell}\n```{webr}\nloan50 |>\n  mutate(homeownership_new = if_else(homeownership %in% c(\"rent\", \"mortgage\"), \"don't own\", homeownership)) |>\n  distinct(homeownership, homeownership_new)\n```\n:::\n\n\n\n\n# Other questions?\n",
    "supporting": [
      "11-midterm-review_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}