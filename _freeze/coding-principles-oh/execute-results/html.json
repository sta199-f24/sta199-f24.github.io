{
  "hash": "d85b57c98957d144661708f6252f1f2b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro to Coding Principles\"\nauthor: \"Dav King + STA 199 Team\"\nformat: \n  html:\n    highlight-style: github\n---\n\n\n\n# Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n# Variables\n\n## Definition\n\nSo what even *is* a variable, in the first place?\nThere are many possible definitions:\n\n-   Anything you assign!\n-   Practically speaking, variables are a way for you to store data without having to type it out every time.\n-   They allow you to manipulate data with the help of pre-built functions (more on that later).\n-   They can also be *changed* - hence the name \"variable\".\n\nWhat are some examples of variables?\n\n-   The simplest is a single value - like in math. I could say \"x = 10\".\n-   It might also be a vector - essentially a list of values. For example, I might just store every name in this class in a vector.\n-   Most frequently, your variables will be your entire data frames.\n\n## Assignment & Saving\n\nOk, these seem pretty useful - so how do we use them?\nIn math and most programming languages, you use the \"=\" operator.\nThis is also possible to do in R:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 10\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\nHowever, in R, we prefer to use the \"\\<-\" operator, to avoid confusion between variable assignment and function arguments.\nHere's how that looks:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 15\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\n### Saving Changes\n\nSuppose you run a function on a variable.\nBy default, R will show you the output of this function, but it will not actually modify your variable.\nFor example, let's look at the `midwest` data set:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   561 ADAMS   IL    0.052    66090      1271.    63917     1702            98\n 2   562 ALEXAN… IL    0.014    10626       759      7054     3496            19\n 3   563 BOND    IL    0.022    14991       681.    14477      429            35\n 4   564 BOONE   IL    0.017    30806      1812.    29344      127            46\n 5   565 BROWN   IL    0.018     5836       324.     5264      547            14\n 6   566 BUREAU  IL    0.05     35688       714.    35157       50            65\n 7   567 CALHOUN IL    0.017     5322       313.     5298        1             8\n 8   568 CARROLL IL    0.027    16805       622.    16519      111            30\n 9   569 CASS    IL    0.024    13437       560.    13384       16             8\n10   570 CHAMPA… IL    0.058   173025      2983.   146506    16559           331\n# ℹ 427 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nNow, let's run a function that \"changes\" the data frame.\nWe can use `select()` to look only at the `county` column:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  select(county)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 1\n   county   \n   <chr>    \n 1 ADAMS    \n 2 ALEXANDER\n 3 BOND     \n 4 BOONE    \n 5 BROWN    \n 6 BUREAU   \n 7 CALHOUN  \n 8 CARROLL  \n 9 CASS     \n10 CHAMPAIGN\n# ℹ 427 more rows\n```\n\n\n:::\n:::\n\n\n\nCool change!\nSo, just to make sure, let's look at the `midwest` data frame one more time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   561 ADAMS   IL    0.052    66090      1271.    63917     1702            98\n 2   562 ALEXAN… IL    0.014    10626       759      7054     3496            19\n 3   563 BOND    IL    0.022    14991       681.    14477      429            35\n 4   564 BOONE   IL    0.017    30806      1812.    29344      127            46\n 5   565 BROWN   IL    0.018     5836       324.     5264      547            14\n 6   566 BUREAU  IL    0.05     35688       714.    35157       50            65\n 7   567 CALHOUN IL    0.017     5322       313.     5298        1             8\n 8   568 CARROLL IL    0.027    16805       622.    16519      111            30\n 9   569 CASS    IL    0.024    13437       560.    13384       16             8\n10   570 CHAMPA… IL    0.058   173025      2983.   146506    16559           331\n# ℹ 427 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nNow wait a minute - what happened here?\nI clearly told it to select the `county` column, and it did!\nSo why is it that, when I went to look at the `midwest` data frame again, it had all of the columns, not just the one that I selected?\n\nThe answer is that we never saved `midwest` back to a variable!\nBy default, R will show the output, but not modify the data frame unless I want it to.\nLet's look at a couple ways we can do that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest <- midwest |>\n  select(county)\n\nmidwest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 1\n   county   \n   <chr>    \n 1 ADAMS    \n 2 ALEXANDER\n 3 BOND     \n 4 BOONE    \n 5 BROWN    \n 6 BUREAU   \n 7 CALHOUN  \n 8 CARROLL  \n 9 CASS     \n10 CHAMPAIGN\n# ℹ 427 more rows\n```\n\n\n:::\n:::\n\n\n\nThe first option is to simply overwrite the variable.\nThis is useful if you're never going to need those data in their original form - it saves you some confusion in that case.\n\nHowever, what if later on I decide I did need those data after all?\nPerhaps I wanted population density data.\nI go to try and find this variable in the `midwest` data set, because that's where I know it's stored...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  select(popdensity)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `select()`:\n! Can't select columns that don't exist.\n✖ Column `popdensity` doesn't exist.\n```\n\n\n:::\n:::\n\n\n\n...but the variable is gone!\nThis is a common point of confusion for students in STA 199, so it's important to understand what you're doing whenever you modify your data in-place like this - you're overwriting the existing data.\n\nWe have a couple of options here.\nIf we were loading these data from a .csv file, we could go back to the top of the document.\nOr, we could do something more effective: Go to Environment, click the little broom icon, and select \"yes\".\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   561 ADAMS   IL    0.052    66090      1271.    63917     1702            98\n 2   562 ALEXAN… IL    0.014    10626       759      7054     3496            19\n 3   563 BOND    IL    0.022    14991       681.    14477      429            35\n 4   564 BOONE   IL    0.017    30806      1812.    29344      127            46\n 5   565 BROWN   IL    0.018     5836       324.     5264      547            14\n 6   566 BUREAU  IL    0.05     35688       714.    35157       50            65\n 7   567 CALHOUN IL    0.017     5322       313.     5298        1             8\n 8   568 CARROLL IL    0.027    16805       622.    16519      111            30\n 9   569 CASS    IL    0.024    13437       560.    13384       16             8\n10   570 CHAMPA… IL    0.058   173025      2983.   146506    16559           331\n# ℹ 427 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nNow the second option: let's try making the modification a little more carefully: saving the data to a new variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest_counties <- midwest |>\n  select(county)\n\nmidwest_counties\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 1\n   county   \n   <chr>    \n 1 ADAMS    \n 2 ALEXANDER\n 3 BOND     \n 4 BOONE    \n 5 BROWN    \n 6 BUREAU   \n 7 CALHOUN  \n 8 CARROLL  \n 9 CASS     \n10 CHAMPAIGN\n# ℹ 427 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmidwest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   561 ADAMS   IL    0.052    66090      1271.    63917     1702            98\n 2   562 ALEXAN… IL    0.014    10626       759      7054     3496            19\n 3   563 BOND    IL    0.022    14991       681.    14477      429            35\n 4   564 BOONE   IL    0.017    30806      1812.    29344      127            46\n 5   565 BROWN   IL    0.018     5836       324.     5264      547            14\n 6   566 BUREAU  IL    0.05     35688       714.    35157       50            65\n 7   567 CALHOUN IL    0.017     5322       313.     5298        1             8\n 8   568 CARROLL IL    0.027    16805       622.    16519      111            30\n 9   569 CASS    IL    0.024    13437       560.    13384       16             8\n10   570 CHAMPA… IL    0.058   173025      2983.   146506    16559           331\n# ℹ 427 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nNow we have two data frames: the new data frame `midwest_counties`, which contains our modifications from the data pipeline above, and the original data frame `midwest`, which has not been changed.\nBoth of these are useful operations, and you will undoubtedly use both this semester!\nHowever, keep this distinction in mind when you're mutating your data - don't remove anything you think you'll need later.\n\n## Variable Examples\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- c(3, 5)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 5\n```\n\n\n:::\n\n```{.r .cell-code}\nz <- midwest\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 437 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   561 ADAMS   IL    0.052    66090      1271.    63917     1702            98\n 2   562 ALEXAN… IL    0.014    10626       759      7054     3496            19\n 3   563 BOND    IL    0.022    14991       681.    14477      429            35\n 4   564 BOONE   IL    0.017    30806      1812.    29344      127            46\n 5   565 BROWN   IL    0.018     5836       324.     5264      547            14\n 6   566 BUREAU  IL    0.05     35688       714.    35157       50            65\n 7   567 CALHOUN IL    0.017     5322       313.     5298        1             8\n 8   568 CARROLL IL    0.027    16805       622.    16519      111            30\n 9   569 CASS    IL    0.024    13437       560.    13384       16             8\n10   570 CHAMPA… IL    0.058   173025      2983.   146506    16559           331\n# ℹ 427 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\n# Data Types\n\n## Examples\n\nEvery column in a data frame will have a particular data type - sort of a way that R recognizes, classifies, and interacts with the data.\nLet's look at an example, using the convenient `glimpse` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(midwest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 437\nColumns: 28\n$ PID                  <int> 561, 562, 563, 564, 565, 566, 567, 568, 569, 570,…\n$ county               <chr> \"ADAMS\", \"ALEXANDER\", \"BOND\", \"BOONE\", \"BROWN\", \"…\n$ state                <chr> \"IL\", \"IL\", \"IL\", \"IL\", \"IL\", \"IL\", \"IL\", \"IL\", \"…\n$ area                 <dbl> 0.052, 0.014, 0.022, 0.017, 0.018, 0.050, 0.017, …\n$ poptotal             <int> 66090, 10626, 14991, 30806, 5836, 35688, 5322, 16…\n$ popdensity           <dbl> 1270.9615, 759.0000, 681.4091, 1812.1176, 324.222…\n$ popwhite             <int> 63917, 7054, 14477, 29344, 5264, 35157, 5298, 165…\n$ popblack             <int> 1702, 3496, 429, 127, 547, 50, 1, 111, 16, 16559,…\n$ popamerindian        <int> 98, 19, 35, 46, 14, 65, 8, 30, 8, 331, 51, 26, 17…\n$ popasian             <int> 249, 48, 16, 150, 5, 195, 15, 61, 23, 8033, 89, 3…\n$ popother             <int> 124, 9, 34, 1139, 6, 221, 0, 84, 6, 1596, 20, 7, …\n$ percwhite            <dbl> 96.71206, 66.38434, 96.57128, 95.25417, 90.19877,…\n$ percblack            <dbl> 2.57527614, 32.90043290, 2.86171703, 0.41225735, …\n$ percamerindan        <dbl> 0.14828264, 0.17880670, 0.23347342, 0.14932156, 0…\n$ percasian            <dbl> 0.37675897, 0.45172219, 0.10673071, 0.48691813, 0…\n$ percother            <dbl> 0.18762294, 0.08469791, 0.22680275, 3.69733169, 0…\n$ popadults            <int> 43298, 6724, 9669, 19272, 3979, 23444, 3583, 1132…\n$ perchsd              <dbl> 75.10740, 59.72635, 69.33499, 75.47219, 68.86152,…\n$ percollege           <dbl> 19.63139, 11.24331, 17.03382, 17.27895, 14.47600,…\n$ percprof             <dbl> 4.355859, 2.870315, 4.488572, 4.197800, 3.367680,…\n$ poppovertyknown      <int> 63628, 10529, 14235, 30337, 4815, 35107, 5241, 16…\n$ percpovertyknown     <dbl> 96.27478, 99.08714, 94.95697, 98.47757, 82.50514,…\n$ percbelowpoverty     <dbl> 13.151443, 32.244278, 12.068844, 7.209019, 13.520…\n$ percchildbelowpovert <dbl> 18.011717, 45.826514, 14.036061, 11.179536, 13.02…\n$ percadultpoverty     <dbl> 11.009776, 27.385647, 10.852090, 5.536013, 11.143…\n$ percelderlypoverty   <dbl> 12.443812, 25.228976, 12.697410, 6.217047, 19.200…\n$ inmetro              <int> 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0…\n$ category             <chr> \"AAR\", \"LHR\", \"AAR\", \"ALU\", \"AAR\", \"AAR\", \"LAR\", …\n```\n\n\n:::\n:::\n\n\n\nNext to the data, we can see various designations - `<int>`, `<dbl>`, `<chr>`, etc.\nThese are **data types**.\nBut what exactly is the difference?\n\n### Double/Numeric\n\nThe `dbl` data type, which is the default implementation of the `numeric` class, stands for **double** - meaning \"double-precision floating-point format\".\nIt's pretty clear that double is an easier word to remember!\nThis allows you to store numbers with a lot of decimal points (but not infinite!).\nFor example, let's look at $\\pi$, which is built in as `pi` in R:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.141593\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nHere, we use the `class()` function to determine what data type R is using to store our variables.\nIn this case, we can see that R stores `pi` as a default `numeric` variable, which is implemented as a double.\nIn general, whenever you work with numbers, they will be doubles, and for purposes of STA 199 there is no issue with this.\n\n### Integer\n\nThe `int` data type means **integer** - as in, the mathematical concept of an integer.\nAll data represented as integers will be whole numbers.\nThis data type is not capable of storing decimal places, so if you try to do decimal operations with it, R will implicitly cast it to another data type.\n**Implicitly** means that it does this without us telling it to.\nLet's take a look at a couple of examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 3\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nBy default, R will treat all numbers as the `numeric` class.\nIf you want to explicitly tell R that your number is an integer, follow the number with \"L\":\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 3L\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\nNow, let's say we want to divide this number by 2:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- a / 2\nclass(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nSince 3 is not divisible by 2, the output is a decimal.\nHowever, since we have performed a decimal operation, rather than trying to guess whether to round up or down, R simply implicitly casts it back to `numeric`.\n\n### Logical/Boolean\n\nWhile there isn't an example in this data frame, there is a data type called **logical** - which represents true/false.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc <- TRUE\nclass(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\nIn R, you need to type out TRUE/FALSE in all caps for it to be recognized.\nUnder the hood, R stores these values as \"FALSE = 0\" and \"TRUE = 1\", which means that if you want to find the percentage of TRUE in your data, you can just take the average:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- c(TRUE, FALSE, TRUE)\nmean(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6666667\n```\n\n\n:::\n:::\n\n\n\n### Character/String\n\nThe `chr` data type represents all **characters** and **strings** in R.\nUnlike some languages, R does not differentiate between these.\nIn general, strings are used to represent words and categorical data, for example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplace <- \"Durham, NC\"\nclass(place)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\nHowever, there is an important point of caution here.\nSometimes, when you load in a data frame, there will be columns that should be represented as numbers, but are accidentally represented as strings.\nIf you're not careful, this can have consequences.\nFor example, consider the following:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0 == 00\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"0\" == \"00\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\nIn R, the numbers 0 and 00 represent the same thing!\nHowever, when they are strings, they do not.\nR treats numbers differently than it does strings, so it's important to pay attention to which one you are actually implementing.\nYou might also run into issues with some of your operations - for example, if you try to take the average of a column of strings, R has no idea what to do and will throw an error.\n\n**Note:** pay attention to the usage of two equal signs here, rather than just one.\nWhy did we do this?\n(More on this shortly.)\n\n## Casting\n\nSo what is the solution to this problem?\nThe answer is called **casting**, which means changing the data type.\nYou do this using the `as.character()`, `as.numeric()`, and `as.logical()` commands.\nLet's look at an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne <- \"00\"\nclass(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"00\"\n```\n\n\n:::\n\n```{.r .cell-code}\ne <- as.numeric(e)\nclass(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ne <- as.logical(e)\nclass(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ne <- as.character(e)\nclass(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"FALSE\"\n```\n\n\n:::\n\n```{.r .cell-code}\ne <- as.numeric(e) # What happened?\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\nBe mindful with your casting - you can lose information along the way!\n\n**Note:** `NA` is a specific type in R.\nIt essentially means \"nothing\" or \"this value has not been declared\".\nYou cannot use == to check whether a value is `NA`.\nInstead, you must use `is.na()`.\n\n# Boolean Operators\n\nSo what *is* going on with the whole == thing, anyway?\nWell, == is one of four so-called **Boolean** or **Logical Operators** - a term we get from computer science.\nThe term basically means \"anything that relies on multiple statements.\" Note that there is a difference between Boolean operators and Boolean (True/False) values - they are actually two entirely different things!\n\n## Equals\n\nThe first Boolean operator is \"equals\".\nThis is a place where it is easy to get confused.\nWe use the single equals sign, =, to denote *assignment* - essentially, telling R \"this thing takes this value.\" We use the double equals sign, ==, to denote *comparison* - essentially, asking R \"are these two values equal?\" It is important to keep these two things distinct - if you want to check equality, or filter for a specific value, you always need to use the double equals sign!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(county = \"Cook\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `filter()`:\n! We detected a named input.\nℹ This usually means that you've used `=` instead of `==`.\nℹ Did you mean `county == \"Cook\"`?\n```\n\n\n:::\n:::\n\n\n\nHere's an example of where a single equals sign is incorrect, and R returns an error.\nFortunately, it has a very helpful suggestion in the error message!\nLet's replace that with the double equals:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(county == \"Cook\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 28\n# ℹ 28 variables: PID <int>, county <chr>, state <chr>, area <dbl>,\n#   poptotal <int>, popdensity <dbl>, popwhite <int>, popblack <int>,\n#   popamerindian <int>, popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>, …\n```\n\n\n:::\n:::\n\n\n\nNow there's no error message, but we also didn't return any values.\nWhy did this happen?\nWhen I use ==, I am checking whether these two strings are *exactly* equivalent, and that includes being case sensitive.\nIf I view the data in the data frame, I see that all of the county names are actually in all caps.\nI can fix the string in my example...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(county == \"COOK\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 28\n    PID county state  area poptotal popdensity popwhite popblack popamerindian\n  <int> <chr>  <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n1   576 COOK   IL    0.058  5105067     88018.  3204947  1317147         10289\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\n...and finally find Chicago!\n\n## And\n\nThe second Boolean operator is \"and\".\nWe use this when we want multiple conditions to be true.\nIn R, to denote and, we use the single ampersand `&` (in some other languages, you use a double ampersand).\nWhen R sees this, it checks both statements, and only returns TRUE if both statements are true.\nLet's look at an example, again using `filter()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(state == \"IL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 102 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   561 ADAMS   IL    0.052    66090      1271.    63917     1702            98\n 2   562 ALEXAN… IL    0.014    10626       759      7054     3496            19\n 3   563 BOND    IL    0.022    14991       681.    14477      429            35\n 4   564 BOONE   IL    0.017    30806      1812.    29344      127            46\n 5   565 BROWN   IL    0.018     5836       324.     5264      547            14\n 6   566 BUREAU  IL    0.05     35688       714.    35157       50            65\n 7   567 CALHOUN IL    0.017     5322       313.     5298        1             8\n 8   568 CARROLL IL    0.027    16805       622.    16519      111            30\n 9   569 CASS    IL    0.024    13437       560.    13384       16             8\n10   570 CHAMPA… IL    0.058   173025      2983.   146506    16559           331\n# ℹ 92 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nUsing our == operator, we can find all of the counties in Illinois.\nNow, let's find only the ones with a population density over 30,000:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(state == \"IL\" & popdensity >= 30000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 28\n    PID county  state  area poptotal popdensity popwhite popblack popamerindian\n  <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n1   576 COOK    IL    0.058  5105067     88018.  3204947  1317147         10289\n2   582 DU PAGE IL    0.02    781666     39083.   714905    15462           962\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nNow, the `filter()` statement is returning all of the rows from this data frame where BOTH the state is \"IL\" AND the population density is $\\geq$ 30,000.\n\n## Or\n\nThe third Boolean operator is \"or\".\nWe use this when we want at least one condition to be true.\nIn R, to denote or, we use the vertical line `|` (again, in some other languages, you use a double line).\nWhen R sees this, it checks both statements, and returns TRUE if either (or both) of the statements are true.\nLet's go back to our example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(state == \"IL\" | popdensity >= 30000) |>\n  arrange(desc(popdensity))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 107 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1   576 COOK    IL    0.058  5105067     88018.  3204947  1317147         10289\n 2  3021 MILWAU… WI    0.015   959275     63952.   718918   195470          6994\n 3  1278 WAYNE   MI    0.035  2111687     60334.  1212007   849109          8048\n 4  2026 CUYAHO… OH    0.026  1412140     54313.  1025756   350185          2533\n 5   582 DU PAGE IL    0.02    781666     39083.   714905    15462           962\n 6   711 MARION  IN    0.023   797159     34659.   615039   169654          1698\n 7  2039 HAMILT… OH    0.025   866228     34649.   672972   181145          1204\n 8   609 LAKE    IL    0.028   516418     18444.   450666    34771          1198\n 9   605 KANE    IL    0.029   317471     10947.   269675    19006           620\n10   661 Winneb… IL    0.03    252913      8430.   222439    23256           651\n# ℹ 97 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nNow, R returns all of the rows that are in Illinois, as well as all of the rows that are not in Illinois, but have a population density of at least 30,000.\n\n**Note:** Keep in mind that `|` is not exclusive.\nThat means that `|` will return true if only one condition is true, but it will also return true if both conditions are true.\nIf you want exactly one condition to be true, look up the operator XOR.\n\n## Not\n\nThe fourth Boolean operator is \"not\".\nWe use this when we want to exclude certain values from the data or prevent something from happening.\nIn R, to denote not, we use the exclamation mark `!`.\nSpecifically, you place the `!`, also known as a **bang sign**, in front of the statement that you want to be false.\nThe most frequent use of this is to say \"not equals\", which is denoted `!=` (note that it is only one equals sign now, not two!) Let's look at an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  filter(state != \"IL\") |>\n  arrange(desc(popdensity))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 335 × 28\n     PID county  state  area poptotal popdensity popwhite popblack popamerindian\n   <int> <chr>   <chr> <dbl>    <int>      <dbl>    <int>    <int>         <int>\n 1  3021 MILWAU… WI    0.015   959275     63952.   718918   195470          6994\n 2  1278 WAYNE   MI    0.035  2111687     60334.  1212007   849109          8048\n 3  2026 CUYAHO… OH    0.026  1412140     54313.  1025756   350185          2533\n 4   711 MARION  IN    0.023   797159     34659.   615039   169654          1698\n 5  2039 HAMILT… OH    0.025   866228     34649.   672972   181145          1204\n 6  2033 FRANKL… OH    0.034   961437     28278.   783714   152840          2056\n 7  1246 MACOMB  MI    0.028   717400     25621.   693686    10400          2639\n 8  2056 LUCAS   OH    0.021   462361     22017.   380155    68456          1164\n 9  2085 SUMMIT  OH    0.024   514990     21458.   446902    61185          1065\n10  2065 MONTGO… OH    0.027   573809     21252.   463551   101817          1065\n# ℹ 325 more rows\n# ℹ 19 more variables: popasian <int>, popother <int>, percwhite <dbl>,\n#   percblack <dbl>, percamerindan <dbl>, percasian <dbl>, percother <dbl>,\n#   popadults <int>, perchsd <dbl>, percollege <dbl>, percprof <dbl>,\n#   poppovertyknown <int>, percpovertyknown <dbl>, percbelowpoverty <dbl>,\n#   percchildbelowpovert <dbl>, percadultpoverty <dbl>,\n#   percelderlypoverty <dbl>, inmetro <int>, category <chr>\n```\n\n\n:::\n:::\n\n\n\nIn these data, all rows from Illinois have been removed.\nYou can check this by commenting out the `filter` line, and observing the difference, or just noting that Cook County, IL (home of Chicago, the densest city in the midwest) is absent!\n\n## Combining Boolean Operators\n\nYou can also combine multiple Boolean operators in more complex logical statements.\nWe will not look at any examples here, because they can get very confusing, very quickly (and are generally unnecessary for this course).\nHowever, if you do want to combine Boolean operators, here are some things to keep in mind:\n\n-   Parentheses: Just like in math, any statements that you put in parentheses will execute first. If I say \"A and B or C\", it's unclear exactly what I mean. If I would accept either (A and B) or (A and C), I would write A & (B \\| C), meaning I need at least one of B or C to be true. If I would accept either (A and B) or C, I would write (A & B) \\| C, meaning I need either (A and B) or C to be true.\n-   Order of operations: Pay attention to the order in which your statements evaluate! If I write !(A & B), that means I need at least one of A or B to be false. If I write !A & !B, that means I need both A and B to be false. This can get confusing, so it's best to write out your logic fully and work through a few examples by hand (or avoid layering these operators entirely).\n\n# Functions\n\n## Definition\n\nWhat is a function?\nA function is, essentially, a block of code that does something (so that *you* don't have to implement it!).\nA function will always have a name, followed by open and closed parentheses ().\nSome functions do not take arguments.\nHowever, if they do, these arguments will go within the parentheses.\nOnce R sees an opening parenthesis, it will not execute the code until it sees a closing parenthesis.\nBeware - when you start layering functions, such as using `aes()` inside of `ggplot()`, you need to pay attention to what your parentheses are around and make sure that they all close!\n\n## Arguments\n\nArguments are the commands that you give to a function that tell it what to do.\nMost functions take at least one argument, and some can take arbitrarily many.\nFunctions have a default order for (some of) their arguments.\nIf you know this order, you do not have to explicitly name the arguments.\nIf not, you must list them explicitly.\nHere are two examples:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Named Arguments\nggplot(\n  data = midwest, \n  mapping = aes(x = poptotal, y = popdensity, color = percwhite)\n  ) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](coding-principles-oh_files/figure-html/ggplot-arguments-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Unnamed Arguments\nggplot(\n  midwest, \n  aes(poptotal, popdensity, percwhite)\n  ) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](coding-principles-oh_files/figure-html/ggplot-arguments-2.png){width=672}\n:::\n:::\n\n\n\nIn ggplot, the first two arguments are always `data` and `mapping`, so it is common to drop these.\nHowever, in the second plot here, we lost our `fill` aesthetic.\nWhy?\n\nWhen we look at the `aes()` documentation, we see that `x` is the first named argument and `y` is the second, but after that there are no named arguments.\nThat means, while you can add more aesthetics, you must name them explicitly, since they do not appear by default.\n\n### Pipe Operator\n\nMany times in this class, you will see the symbol `|>` used.\nThis is known as the **pipe operator**, and it allows us to have a so-called \"data pipeline\".\nThis helps make code a lot more readable!\nLet's take a look at why:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(arrange(mutate(select(filter(midwest, state == \"IL\"), county, state, area, poptotal, inmetro), inmetro = as.logical(inmetro)), desc(poptotal)), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 5\n   county    state  area poptotal inmetro\n   <chr>     <chr> <dbl>    <int> <lgl>  \n 1 COOK      IL    0.058  5105067 TRUE   \n 2 DU PAGE   IL    0.02    781666 TRUE   \n 3 LAKE      IL    0.028   516418 TRUE   \n 4 WILL      IL    0.05    357313 TRUE   \n 5 KANE      IL    0.029   317471 TRUE   \n 6 ST CLAIR  IL    0.04    262852 TRUE   \n 7 Winnebago IL    0.03    252913 TRUE   \n 8 MADISON   IL    0.045   249238 TRUE   \n 9 MCHENRY   IL    0.036   183241 TRUE   \n10 PEORIA    IL    0.038   182827 TRUE   \n```\n\n\n:::\n:::\n\n\n\nTechnically, we can write our code in this manner!\nStrictly speaking, under the hood, the pipe operator is reconstructing your code into this format.\nHowever, this is nearly impossible to read (I've been coding in R for years, and I still ran into multiple errors trying to write this).\n\nWith the pipe operator, we can skip this and execute each function on its own line.\nBy default, the pipe operator \"pipes\" your data into the first argument of a function - which, in the tidyverse, is almost always the \"data\" argument.\nThis lets us write our data in a much neater pipeline, where you can see step-by-step what is happening to the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>   # Operate on the midwest data frame\n  filter(state == \"IL\") |>   # Filter for only the counties in Illinois\n  select(county, state, area, poptotal, inmetro) |>   # Select only these five columns, and drop all others\n  mutate(inmetro = as.logical(inmetro)) |>   # Cast inmetro to a logical type\n  arrange(desc(poptotal)) |>   # Arrange the data frame by poptotal in descending order\n  head(10)   # Select the top 10 rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 5\n   county    state  area poptotal inmetro\n   <chr>     <chr> <dbl>    <int> <lgl>  \n 1 COOK      IL    0.058  5105067 TRUE   \n 2 DU PAGE   IL    0.02    781666 TRUE   \n 3 LAKE      IL    0.028   516418 TRUE   \n 4 WILL      IL    0.05    357313 TRUE   \n 5 KANE      IL    0.029   317471 TRUE   \n 6 ST CLAIR  IL    0.04    262852 TRUE   \n 7 Winnebago IL    0.03    252913 TRUE   \n 8 MADISON   IL    0.045   249238 TRUE   \n 9 MCHENRY   IL    0.036   183241 TRUE   \n10 PEORIA    IL    0.038   182827 TRUE   \n```\n\n\n:::\n:::\n\n\n\nMuch better, right?\nRemember, whenever you're using the pipe operator (or the +, in `ggplot`, which is different!), you should start a new line of code.\nAs long as you have a pipe operator, R is expecting another function, so it won't execute only part of your code.\n\n**Note:** In this class, we focus on the base R pipe, which is denoted by `|>`.\nHowever, when you're debugging on the internet, you may come across the symbol `%>%`, which is the `magrittr` pipe.\nThere are some technical differences in these that generally go beyond the scope of this class, but they essentially serve the same purpose.\nDon't be scared by the `magrittr` pipe when you're doing your debugging!\n\n# Libraries\n\n## Definition\n\nEvery time we start programming in this class, we run `library(tidyverse)`.\nWhy do we do this?\n\nLibraries are collections of functions, and running them means that we are loading those functions into our current R session.\nIf you try to open up a fresh R session and run `ggplot()` immediately, you will get an error, because that function is not found.\nHowever, with the library, you can load in everything that you need, all at once.\nThe tidyverse is especially cool, because it is actually a collection of libraries - libraryception!\n\n## Environment\n\nYour environment in R is basically the current instance of your program.\nWhen you run a library, it is part of your environment until you restart R, meaning you can call any of its functions at any time.\nWhen you create a variable, it is part of your environment until you restart R, meaning you can reference those variables at any time.\n\nWhen you use the containers, they do not regularly restart R.\nThis can be a problem sometimes, when old code gets tangled up with new code!\nIt is my personal recommendation that you (at a minimum) restart R and clear your environment every time you start a new project (AE, lab, etc).\nYou can restart R by going to Session -\\> Restart R, and clear your environment by going to the environment pane and clicking the broom icon.\n\n## Rendering Quarto\n\nWhen you click the \"Render\" button for your .qmd file, what happens?\nR executes a program, called a \"compiler\", that runs your entire .qmd file in a new environment.\nIn other words, if you have loaded a library, or edited a variable, or done any number of things in the console (or even later in the .qmd file) without saving them in the .qmd file, and then you try to render, you will get an error because that function/variable/etc has not been defined in the rendering environment.\nThis forces you to write reproducible code, and it's the first thing to think about when you run into errors while rendering!\n\n# Documentation + Errors\n\n## Documentation\n\nUnless you have a function and its usage entirely memorized, you are going to be reading documentation.\nDocumentation is useful, but it is dense, and can be hard to parse.\nLet's look at an example of how we can look through documentation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?if_else\n\n?geom_point\n```\n:::\n\n\n\n## Errors\n\nUnless you are the Roman God of Programming (and even then, I'm not too sure), you are going to encounter errors in your programming.\nThese are completely natural, and nothing to be ashamed of - sometimes I write partial code, just to see where it will catch errors.\nHowever, some error messages are easier to understand than others.\nLet's look through a couple of examples of common errors, and what I would do to interpret and fix them.\n\n## Example 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmidwest |>\n  sumarize(avg_pop_dens = mean(popdensity))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sumarize(midwest, avg_pop_dens = mean(popdensity)): could not find function \"sumarize\"\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## What's wrong with this code?\n\nIn this case, we just have a simple spelling error!\nIt may seem trivial, but this will constitute at least half of the errors that you have.\nMake this the first thing you check - you will never meet a programmer who doesn't have a story of the time they spent at least 30 minutes debugging a function, just to realize it was a typo all along.\n:::\n\n## Example 2\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(midwest, aes(x = poptotal, y = popdensity,)) |>\n  geom_point() |>\n  labs(x = \"Total Population\", y = \"Population Density\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `geom_point()`:\n! `mapping` must be created by `aes()`.\nℹ Did you use `%>%` or `|>` instead of `+`?\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## What's wrong with this code?\n\nThis one should be pretty obvious, since it's a common enough error that R gives an extremely helpful error message.\nWhen you're building a `ggplot` object, you use `+` rather than `|>` to add additional lines!\n\nThere's a second error here, that R knew well enough to handle here, but which could become an issue in more complicated code chunks.\nDid anyone spot it?\n:::\n\n## Example 3\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(midwest, aes(x = state, y = poptotal, fill = state)) +\n  geom_bar() +\n  theme_bw() +\n  scale_y_continuous(labels = scales::unit_format(unit = \"M\", scale = 1e-6)) +\n  labs(\n    x = \"State\",\n    y = \"Total Population\\n(Millions)\",\n    title = \"Total Population by State\"\n  ) +\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"none\"\n  ) +\n  scale_fill_viridis_d()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `geom_bar()`:\n! Problem while computing stat.\nℹ Error occurred in the 1st layer.\nCaused by error in `setup_params()`:\n! `stat_count()` must only have an x or y aesthetic.\n```\n\n\n:::\n:::\n\n\n\nThere's a lot going on here, so it might not be obvious at first where the issue is!\nThe error has something to do with the function `stat_count()`, but that's not a function we used (explicitly) anywhere in this code.\nThis is why you should iterate on your code, running it intermittently, so that you can catch errors when they pop up.\n\nMy first thought would be to run `rlang::last_trace()`, as suggested by the error message.\nThis is sometimes helpful - it can reference certain functions and even lines of code, especially when you're executing something more complex.\nFrequently, though, it's too complicated to understand.\nIn this case, I would certainly say I can't make any sense of that.\n\nMy next thought is to google the error message.\nIt can be a little tricky to know what to google from the error message.\nYou want to look for anything that seems general enough that other people might have asked, but specific enough that it will apply to your situation.\nLet's go line by line:\n\n-   \"Error in `geom_bar()`\": Probably too general to bother googling. There are a lot of possible errors with `geom_bar()`, and it would take too long to look through them all to get to your specific problem!\n-   \"Problem while computing stat.\": This is more helpful, because it gives a little more direction as to the source of the error, but it is still too general - what stat are we computing? What problem?\n-   \"Error occured in the 1st layer\": This can be helpful for you, if you know the order of `ggplot` layers. However, it is probably not helpful to google, since people could have built their layers in a different order before encountering this error.\n-   \"Caused by error in `setup_params()`\": Closer! This is getting more and more specific, and this might be good enough to google. However, it still doesn't say what the error is, it just says that there was one.\n-   \"`stat_count()` must only have an `x` or `y` aesthetic\": Bingo! This is the one we're looking for, which tells us exactly what the issue is. Now, it may be possible to interpret manually, but let's say you can't. Here's where we go now:\n\nI would copy-paste the entire final line into google.\nYou don't want to copy-paste the full error message, since that's probably too specific, and you might not find any results.\nAt the same time, you don't want to copy-paste only a couple of words, since that might not be specific enough, and you could be stuck looking through a lot of links.\nIf you google just that line, you are likely to find someone on stack exchange who has posted a question with this exact (or almost this exact) error message.\nYou can also help your google out by throwing in some relevant key words:\n\n-   ggplot\n-   R\n-   error\n\nTake a couple minutes to google this, and see if you can figure out what's wrong with the code!\nThen, remember to cite the source where you found this answer!\nIn general, it's okay to google your error messages for help, but not to use someone else's solution without credit.\n\n::: {.callout-tip collapse=\"true\"}\n## What's wrong with this code?\n\nI looked at <https://stackoverflow.com/questions/61068031/error-stat-count-can-only-have-an-x-or-y-aesthetic> for my answer.\nThere's a few different suggestions on this page, all of which could be useful!\nThis page definitely suggests to me that the issue with my plot is in the `geom_bar()` line - which makes sense, since this is layer 1 of the plot.\nWhile they have a couple simple fixes, here's the actual error I wrote: `geom_bar()` is expecting only one variable.\nIf you want two variables, like this, you should use `geom_col()` instead.\n:::\n\n# Conclusion\n\nI hope this has given you some tips and tricks for how to use R and how to fix your errors on your own!\nRemember, we are always willing to answer questions, and the more you write code, the more you'll understand it.\nCoding is all about attention to detail: the machine does *exactly* what you tell it to do, whether or not that's what you actually wanted.\nTry to break things, to find out what you can and can't do, and remember - we were all beginner programmers at one point!\n",
    "supporting": [
      "coding-principles-oh_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}